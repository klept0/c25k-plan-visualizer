"""
API Integration module for connecting to various fitness platforms.
Supports Strava, RunKeeper, Garmin Connect, Intervals.icu, and weather APIs.
"""

import json
import requests
from typing import Any, Dict, List, Optional
from datetime import datetime
import os
import logging
from dataclasses import dataclass


@dataclass
class APICredentials:
    """Data class for storing API credentials"""
    client_id: str
    client_secret: str
    access_token: Optional[str] = None
    refresh_token: Optional[str] = None
    expires_at: Optional[datetime] = None


@dataclass
class WorkoutData:
    """Structured workout data for API exports"""
    date: datetime
    duration_minutes: int
    activity_type: str
    name: str
    description: str
    intervals: List[Dict[str, Any]]
    distance_meters: Optional[float] = None
    calories: Optional[int] = None


class BaseAPIClient:
    """Base class for all API integrations"""
    
    def __init__(self, credentials: APICredentials):
        self.credentials = credentials
        self.base_url = ""
        self.session = requests.Session()
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def authenticate(self) -> bool:
        """Authenticate with the API"""
        raise NotImplementedError
    
    def refresh_access_token(self) -> bool:
        """Refresh expired access token"""
        raise NotImplementedError
    
    def upload_workout(self, workout: WorkoutData) -> bool:
        """Upload a single workout"""
        raise NotImplementedError
    
    def upload_training_plan(self, workouts: List[WorkoutData]) -> bool:
        """Upload multiple workouts as a training plan"""
        for workout in workouts:
            if not self.upload_workout(workout):
                return False
        return True


class StravaAPIClient(BaseAPIClient):
    """Strava API integration for uploading C25K training plans"""
    
    def __init__(self, credentials: APICredentials):
        super().__init__(credentials)
        self.base_url = "https://www.strava.com/api/v3"
    
    def authenticate(self) -> bool:
        """Authenticate with Strava using OAuth2"""
        try:
            auth_url = "https://www.strava.com/oauth/authorize"
            params = {
                "client_id": self.credentials.client_id,
                "response_type": "code",
                "redirect_uri": "http://localhost:8000/callback",
                "approval_prompt": "force",
                "scope": "activity:write"
            }
            
            # This would open a browser for OAuth flow in a real implementation
            self.logger.info(f"Please visit: {auth_url}?" + "&".join([f"{k}={v}" for k, v in params.items()]))
            return True
            
        except Exception as e:
            self.logger.error(f"Strava authentication failed: {e}")
            return False
    
    def upload_workout(self, workout: WorkoutData) -> bool:
        """Upload a C25K workout to Strava"""
        try:
            # Convert C25K intervals to Strava activity format
            activity_data = {
                "name": workout.name,
                "type": "Run",
                "start_date_local": workout.date.isoformat(),
                "elapsed_time": workout.duration_minutes * 60,
                "description": self._format_c25k_description(workout),
                "trainer": False,
                "commute": False
            }
            
            headers = {
                "Authorization": f"Bearer {self.credentials.access_token}",
                "Content-Type": "application/json"
            }
            
            response = self.session.post(
                f"{self.base_url}/activities",
                json=activity_data,
                headers=headers
            )
            
            return response.status_code == 201
            
        except Exception as e:
            self.logger.error(f"Failed to upload workout to Strava: {e}")
            return False
    
    def _format_c25k_description(self, workout: WorkoutData) -> str:
        """Format C25K workout description for Strava"""
        description = f"{workout.description}\n\n🏃‍♀️ Intervals:\n"
        for interval in workout.intervals:
            description += f"• {interval['type'].title()}: {interval['duration']}min\n"
        description += "\n📱 Generated by C25K Calendar Creator"
        return description


class IntervalsICUClient(BaseAPIClient):
    """Intervals.icu API integration for structured training plans"""
    
    def __init__(self, credentials: APICredentials):
        super().__init__(credentials)
        self.base_url = "https://intervals.icu/api/v1"
    
    def authenticate(self) -> bool:
        """Authenticate with intervals.icu using API key"""
        try:
            headers = {"Authorization": f"Basic {self.credentials.access_token}"}
            response = self.session.get(f"{self.base_url}/athlete", headers=headers)
            return response.status_code == 200
        except Exception as e:
            self.logger.error(f"Intervals.icu authentication failed: {e}")
            return False
    
    def upload_workout(self, workout: WorkoutData) -> bool:
        """Upload a structured C25K workout to intervals.icu"""
        try:
            # intervals.icu excels at structured workouts with power/pace targets
            workout_data = {
                "start_date_local": workout.date.strftime("%Y-%m-%d"),
                "type": "Run",
                "name": workout.name,
                "description": workout.description,
                "planned": True,
                "steps": self._convert_c25k_to_intervals_steps(workout.intervals)
            }
            
            headers = {
                "Authorization": f"Basic {self.credentials.access_token}",
                "Content-Type": "application/json"
            }
            
            response = self.session.post(
                f"{self.base_url}/athlete/{self._get_athlete_id()}/activities",
                json=workout_data,
                headers=headers
            )
            
            return response.status_code == 200
            
        except Exception as e:
            self.logger.error(f"Failed to upload workout to intervals.icu: {e}")
            return False
    
    def _convert_c25k_to_intervals_steps(self, intervals: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Convert C25K intervals to intervals.icu workout steps"""
        steps = []
        
        for i, interval in enumerate(intervals):
            if interval['type'] == 'warmup':
                steps.append({
                    "step": i + 1,
                    "type": "warmup",
                    "duration": interval['duration'] * 60,  # Convert to seconds
                    "target_type": "pace",
                    "target_zone": "Z1",  # Easy pace
                    "text": "Warm-up walk"
                })
            elif interval['type'] == 'run':
                steps.append({
                    "step": i + 1,
                    "type": "work",
                    "duration": interval['duration'] * 60,
                    "target_type": "pace",
                    "target_zone": "Z2",  # Aerobic base
                    "text": f"Run {interval['duration']} minutes"
                })
            elif interval['type'] == 'walk':
                steps.append({
                    "step": i + 1,
                    "type": "recovery",
                    "duration": interval['duration'] * 60,
                    "target_type": "pace",
                    "target_zone": "Z1",
                    "text": f"Recovery walk {interval['duration']} minutes"
                })
            elif interval['type'] == 'cooldown':
                steps.append({
                    "step": i + 1,
                    "type": "cooldown",
                    "duration": interval['duration'] * 60,
                    "target_type": "pace",
                    "target_zone": "Z1",
                    "text": "Cool-down walk"
                })
        
        return steps
    
    def _get_athlete_id(self) -> str:
        """Get the athlete ID for the authenticated user"""
        # This would be cached after first authentication
        headers = {"Authorization": f"Basic {self.credentials.access_token}"}
        response = self.session.get(f"{self.base_url}/athlete", headers=headers)
        if response.status_code == 200:
            return response.json()["id"]
        return ""


class RunKeeperAPIClient(BaseAPIClient):
    """RunKeeper API integration"""
    
    def __init__(self, credentials: APICredentials):
        super().__init__(credentials)
        self.base_url = "https://api.runkeeper.com"
    
    def authenticate(self) -> bool:
        """Authenticate with RunKeeper"""
        # Similar OAuth2 flow as Strava
        return True
    
    def upload_workout(self, workout: WorkoutData) -> bool:
        """Upload workout to RunKeeper"""
        try:
            activity_data = {
                "type": "Running",
                "start_time": workout.date.isoformat(),
                "duration": workout.duration_minutes * 60,
                "notes": workout.description,
                "path": []  # GPS path would go here if available
            }
            
            headers = {
                "Authorization": f"Bearer {self.credentials.access_token}",
                "Content-Type": "application/vnd.com.runkeeper.FitnessActivity+json"
            }
            
            response = self.session.post(
                f"{self.base_url}/fitnessActivities",
                json=activity_data,
                headers=headers
            )
            
            return response.status_code == 201
            
        except Exception as e:
            self.logger.error(f"Failed to upload workout to RunKeeper: {e}")
            return False


class GarminConnectClient(BaseAPIClient):
    """Garmin Connect API integration"""
    
    def __init__(self, credentials: APICredentials):
        super().__init__(credentials)
        self.base_url = "https://connect.garmin.com/modern/proxy"
    
    def authenticate(self) -> bool:
        """Authenticate with Garmin Connect"""
        # Garmin uses a different auth mechanism
        return True
    
    def upload_workout(self, workout: WorkoutData) -> bool:
        """Upload structured workout to Garmin Connect"""
        # Garmin Connect supports .fit files and structured workouts
        return True


class WeatherAPIClient:
    """Weather API integration for workout recommendations"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.openweathermap.org/data/2.5"
        self.session = requests.Session()
    
    def get_current_weather(self, lat: float, lon: float) -> Dict[str, Any]:
        """Get current weather conditions"""
        try:
            params = {
                "lat": lat,
                "lon": lon,
                "appid": self.api_key,
                "units": "metric"
            }
            
            response = self.session.get(f"{self.base_url}/weather", params=params)
            
            if response.status_code == 200:
                return response.json()
            return {}
            
        except Exception as e:
            logging.error(f"Weather API error: {e}")
            return {}
    
    def get_forecast(self, lat: float, lon: float, days: int = 5) -> List[Dict[str, Any]]:
        """Get weather forecast for training planning"""
        try:
            params = {
                "lat": lat,
                "lon": lon,
                "appid": self.api_key,
                "units": "metric",
                "cnt": days * 8  # 8 forecasts per day (3-hour intervals)
            }
            
            response = self.session.get(f"{self.base_url}/forecast", params=params)
            
            if response.status_code == 200:
                return response.json().get("list", [])
            return []
            
        except Exception as e:
            logging.error(f"Weather forecast API error: {e}")
            return []
    
    def get_running_recommendation(self, weather_data: Dict[str, Any]) -> str:
        """Get running recommendation based on weather"""
        temp = weather_data.get("main", {}).get("temp", 20)
        humidity = weather_data.get("main", {}).get("humidity", 50)
        wind_speed = weather_data.get("wind", {}).get("speed", 0)
        conditions = weather_data.get("weather", [{}])[0].get("main", "Clear")
        
        if conditions in ["Rain", "Thunderstorm"]:
            return "🌧️ Consider indoor training or postpone to avoid safety risks"
        elif conditions == "Snow":
            return "❄️ Be extra careful with footing, consider treadmill training"
        elif temp < 0:
            return "🥶 Very cold! Warm up indoors, dress in layers, protect extremities"
        elif temp < 10:
            return "🧥 Cool weather - perfect for running! Dress in layers"
        elif temp > 30:
            return "🌡️ Hot weather - run early morning/evening, stay hydrated"
        elif humidity > 80:
            return "💧 High humidity - take it easier, hydrate more frequently"
        elif wind_speed > 10:
            return "💨 Windy conditions - adjust pace, start into the wind"
        else:
            return "✅ Great conditions for running! Perfect weather for your C25K session"


class APIManager:
    """Central manager for all API integrations"""
    
    def __init__(self):
        self.clients = {}
        self.weather_client = None
        self.credentials_file = "api_credentials.json"
    
    def load_credentials(self) -> Dict[str, APICredentials]:
        """Load API credentials from secure storage"""
        try:
            if os.path.exists(self.credentials_file):
                with open(self.credentials_file, 'r') as f:
                    data = json.load(f)
                    return {
                        service: APICredentials(**creds) 
                        for service, creds in data.items()
                    }
        except Exception as e:
            logging.error(f"Failed to load credentials: {e}")
        return {}
    
    def setup_client(self, service: str, credentials: APICredentials) -> bool:
        """Setup API client for a specific service"""
        try:
            if service.lower() == "strava":
                self.clients[service] = StravaAPIClient(credentials)
            elif service.lower() == "intervals.icu":
                self.clients[service] = IntervalsICUClient(credentials)
            elif service.lower() == "runkeeper":
                self.clients[service] = RunKeeperAPIClient(credentials)
            elif service.lower() == "garmin":
                self.clients[service] = GarminConnectClient(credentials)
            else:
                return False
            
            return self.clients[service].authenticate()
            
        except Exception as e:
            logging.error(f"Failed to setup {service} client: {e}")
            return False
    
    def setup_weather_client(self, api_key: str) -> bool:
        """Setup weather API client"""
        try:
            self.weather_client = WeatherAPIClient(api_key)
            return True
        except Exception as e:
            logging.error(f"Failed to setup weather client: {e}")
            return False
    

    def export_to_platform(self, service: str, workouts: List[WorkoutData]) -> bool:
        """Export training plan to a specific platform, respecting user integration preferences."""
        # Check user preferences for enabled integrations
        prefs_path = os.path.join(os.path.expanduser("~"), ".c25k_prefs.json")
        enabled = True
        try:
            if os.path.exists(prefs_path):
                with open(prefs_path, "r", encoding="utf-8") as f:
                    prefs = json.load(f)
                key_map = {
                    "strava": "strava_enabled",
                    "runkeeper": "runkeeper_enabled",
                    "garmin": "garmin_enabled",
                    "intervals.icu": "intervals_enabled",
                }
                pref_key = key_map.get(service.lower())
                if pref_key is not None:
                    enabled = prefs.get(pref_key, True)
        except Exception as e:
            logging.error(f"Failed to check integration preferences: {e}")
            enabled = True  # Default to enabled if error
        if not enabled:
            logging.info(f"Integration for {service} is disabled in user preferences.")
            return False
        if service not in self.clients:
            logging.error(f"Client for {service} not configured")
            return False
        return self.clients[service].upload_training_plan(workouts)
    
    def get_weather_recommendation(self, lat: float, lon: float) -> str:
        """Get weather-based training recommendation"""
        if not self.weather_client:
            return "Weather data unavailable - proceed with normal training"
        
        weather_data = self.weather_client.get_current_weather(lat, lon)
        if weather_data:
            return self.weather_client.get_running_recommendation(weather_data)
        
        return "Weather data unavailable - proceed with normal training"


def convert_c25k_plan_to_workouts(plan_data: Dict[str, Any]) -> List[WorkoutData]:
    """Convert C25K plan data to structured workout format"""
    workouts = []
    
    for session in plan_data.get("sessions", []):
        # Parse the workout description to extract intervals
        intervals = _parse_c25k_intervals(session.get("description", ""))
        
        workout = WorkoutData(
            date=datetime.fromisoformat(session.get("date", "")),
            duration_minutes=session.get("duration", 30),
            activity_type="Running",
            name=session.get("title", "C25K Session"),
            description=session.get("description", ""),
            intervals=intervals
        )
        
        workouts.append(workout)
    
    return workouts


def _parse_c25k_intervals(description: str) -> List[Dict[str, Any]]:
    """Parse C25K workout description to extract interval structure"""
    intervals = []
    
    # Add warmup
    intervals.append({"type": "warmup", "duration": 5})
    
    # Parse the main workout from description
    if "run 60 sec, walk 90 sec" in description.lower():
        # Week 1 structure
        for _ in range(8):
            intervals.append({"type": "run", "duration": 1})
            intervals.append({"type": "walk", "duration": 1.5})
    elif "run 90 sec, walk 2 min" in description.lower():
        # Week 2 structure
        for _ in range(6):
            intervals.append({"type": "run", "duration": 1.5})
            intervals.append({"type": "walk", "duration": 2})
    elif "20 min" in description.lower() and "no walking" in description.lower():
        # Continuous run
        intervals.append({"type": "run", "duration": 20})
    elif "25 min" in description.lower():
        intervals.append({"type": "run", "duration": 25})
    elif "28 min" in description.lower():
        intervals.append({"type": "run", "duration": 28})
    elif "30 min" in description.lower():
        intervals.append({"type": "run", "duration": 30})
    
    # Add cooldown
    intervals.append({"type": "cooldown", "duration": 5})
    
    return intervals
